---
title: ML - Intermediate Machine Learning
date: 2019-10-11 11:11:11 -0400
categories: [1CodeNote, MLNote]
tags: [ML]
toc: true
---

- [Intro to Machine Learning](#intro-to-machine-learning)
  - [How Models Work](#how-models-work)
  - [over all](#over-all)
  - [Your First Machine Learning Model - `DecisionTreeRegressor`](#your-first-machine-learning-model---decisiontreeregressor)
  - [Model Validation](#model-validation)
    - [Mean Absolute Error (MAE)](#mean-absolute-error-mae)
  - [Underfitting and Overfitting](#underfitting-and-overfitting)
  - [Random Forests -`RandomForestRegressor`](#random-forests--randomforestregressor)
  - [example](#example)

- ref:
  - https://www.kaggle.com/learn/intermediate-machine-learning

---

# ML - Intermediate Machine Learning

> Welcome to Kaggle Learn's Intermediate Machine Learning micro-course!

> If you have some background in machine learning and you'd like to learn how to quickly improve the quality of your models, you're in the right place! In this micro-course, you will accelerate your machine learning expertise by learning how to:

- tackle data types often found in real-world datasets (**missing values, categorical variables**),
- design **pipelines** to improve the quality of your machine learning code,
- use advanced techniques for model validation (**cross-validation**),
- build state-of-the-art models that are widely used to win Kaggle competitions (**XGBoost**), and
- avoid common and important data science mistakes (**leakage**).

---
 
## Missing Values

Most machine learning libraries (including scikit-learn) give an error if you try to build a model using data with missing values. So you'll need to choose one of the strategies below.



example:

```py
import pandas as pd
from sklearn.model_selection import train_test_split

# Load the data
data = pd.read_csv('../input/melbourne-housing-snapshot/melb_data.csv')

# Select target
y = data.Price

# To keep things simple, we'll use only numerical predictors
melb_predictors = data.drop(['Price'], axis=1)
X = melb_predictors.select_dtypes(exclude=['object'])

# Divide data into training and validation subsets
X_train, X_valid, y_train, y_valid = train_test_split(
  X, y, train_size=0.8, test_size=0.2, random_state=0)


from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_absolute_error

# Function for comparing different approaches
def score_dataset(X_train, X_valid, y_train, y_valid):
    model = RandomForestRegressor(n_estimators=10, random_state=0)
    model.fit(X_train, y_train)
    preds = model.predict(X_valid)
    return mean_absolute_error(y_valid, preds)
```


**Three Approaches**
1. Drop Columns with Missing Values
   - simplest option is to drop columns with missing values.
   - Unless most values in the dropped columns are missing, the model loses access to a lot of (potentially useful!) information with this approach. 
   - As an extreme example, consider a dataset with 10,000 rows, where one important column is missing a single entry. This approach would drop the column entirely!

2. A Better Option: Imputation
   - Imputation fills in the missing values with some number. 
   - For instance, we can fill in the mean value along each column.
   - The imputed value won't be exactly right in most cases, but it usually leads to more accurate models than you would get from dropping the column entirely.

3. An Extension To Imputation
   - Imputation is the standard approach, and it usually works well. 
   - However, imputed values may be systematically above or below their actual values (which weren't collected in the dataset). Or rows with missing values may be unique in some other way. 
   - In that case, your model would make better predictions by considering which values were originally missing.
   - In this approach, we impute the missing values, as before. And, additionally, for each column with missing entries in the original dataset, we add a new column that shows the location of the imputed entries.
   - In some cases, this will meaningfully improve results. In other cases, it doesn't help at all.



### Score from Approach 1 (Drop Columns with Missing Values)

- Since we are working with both training and validation sets, we are careful to drop the same columns in both DataFrames.

```py
# Get names of columns with missing values
cols_with_missing = [col for col in X_train.columns if X_train[col].isnull().any()]

# Drop columns in training and validation data
reduced_X_train = X_train.drop(cols_with_missing, axis=1)
reduced_X_valid = X_valid.drop(cols_with_missing, axis=1)

print("MAE from Approach 1 (Drop columns with missing values):")
print(score_dataset(reduced_X_train, reduced_X_valid, y_train, y_valid))
# MAE from Approach 1 (Drop columns with missing values):
# 183550.22137772635
```



### Score from Approach 2 (Imputation)

- use SimpleImputer to replace missing values with the mean value along each column.

Although it's simple, filling in the mean value generally performs quite well (but this varies by dataset). While statisticians have experimented with more complex ways to determine imputed values (such as regression imputation, for instance), the complex strategies typically give no additional benefit once you plug the results into sophisticated machine learning models.

```py
from sklearn.impute import SimpleImputer

# Imputation
my_imputer = SimpleImputer()
imputed_X_train = pd.DataFrame(my_imputer.fit_transform(X_train))
imputed_X_valid = pd.DataFrame(my_imputer.transform(X_valid))

# Imputation removed column names; put them back
imputed_X_train.columns = X_train.columns
imputed_X_valid.columns = X_valid.columns

print("MAE from Approach 2 (Imputation):")
print(score_dataset(imputed_X_train, imputed_X_valid, y_train, y_valid))
MAE from Approach 2 (Imputation):
178166.46269899711

```











.
